# gpt's solution
# DP(동적 계획법): 큰 문제를 작은 문제로 쪼개어 그 결과를 저장하고, 이를 재활용하면서 문제를 해결하는 방식.
# 한 번 계산한 값을 저장해서 같은 계산을 반복하지 않도록 하는 것이 핵심.

# 요약 결국 그냥 피보나치 수열임. 앞으로 경우의 수를 좀 더 나열해보고 쉬운 방법이 있는지 탐구할 것

def solution(n):
    MOD = 1000000007  # 값이 매우 커질 수 있기 때문에, 결과를 1,000,000,007로 나눈 나머지를 구하기 위해 사용
    # 1,000,000,007은 흔히 사용하는 큰 소수로, 나머지를 구할 때 사용하면 오버플로우를 방지할 수 있음

    # (예외 조건)
    if n == 1:
        return 1  # n이 1일 때는 타일을 세로로 하나만 놓을 수 있으므로 경우의 수는 1
    elif n == 2:
        return 2  # n이 2일 때는 타일을 세로로 두 개 놓거나 가로로 두 개 놓을 수 있으므로 경우의 수는 2

    # DP 테이블 초기화
    dp = [0] * (n + 1)  # 크기가 n+1인 배열을 생성, 각 인덱스는 가로 길이별 경우의 수를 저장
    dp[1] = 1  # n이 1일 때의 경우의 수
    dp[2] = 2  # n이 2일 때의 경우의 수

    # 점화식을 사용하여 DP 테이블을 채움
    # dp[i]는 가로 길이가 i일 때 타일을 배치하는 방법의 수
    for i in range(3, n + 1):  # 3부터 n까지의 경우의 수를 계산
        dp[i] = (dp[i-1] + dp[i-2]) % MOD
        # dp[i-1]: 가로 길이가 i-1인 상태에서 타일 하나를 세로로 배치한 경우
        # dp[i-2]: 가로 길이가 i-2인 상태에서 타일 두 개를 가로로 배치한 경우
        # 두 경우를 더하면 가로 길이 i를 타일로 채우는 모든 방법의 수가 됨
        # 값이 너무 커질 수 있으므로 1,000,000,007로 나눈 나머지를 저장

    return dp[n]  # 최종적으로 가로 길이가 n일 때의 경우의 수를 반환

# 예시 실행
print(solution(30))  # 가로 길이가 30인 직사각형을 채우는 방법의 수 출력

# for i in range(1, 20):
#   print(solution(i))