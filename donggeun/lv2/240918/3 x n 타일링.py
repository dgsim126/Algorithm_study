# 이해가 잘 안 됨.
def solution(n):
    MOD = 1000000007  # 경우의 수가 매우 클 수 있으므로 1,000,000,007로 나눈 나머지를 반환

    # 가로 길이가 1인 경우 3x1 크기의 직사각형은 채울 수 없으므로 0을 반환
    if n == 1:
        return 0
    # 가로 길이가 2인 경우 3x2 크기의 직사각형을 채우는 방법은 3가지
    elif n == 2:
        return 3

    # DP 테이블을 초기화, dp[i]는 가로 길이가 i일 때 직사각형을 채우는 방법의 수를 저장
    dp = [0] * (n + 1)

    # 초기값 설정: 가로 길이 2인 경우 방법의 수는 3
    dp[2] = 3  # 3x2 크기를 채우는 방법

    # 가로 길이가 4 이상일 때부터 DP 점화식을 적용
    for i in range(4, n + 1, 2):  # 가로 길이가 짝수일 때만 타일링 가능하므로 2씩 증가
        # 가로 길이가 i일 때, 이전 가로 길이 (i-2)를 기반으로 새로운 3x2 타일을 채워넣는 경우
        dp[i] = (dp[i - 2] * 3) % MOD

        # j는 4부터 i까지 2씩 증가하며, 더 작은 직사각형을 채우는 방법을 고려
        for j in range(4, i, 2):
            dp[i] = (dp[i] + dp[i - j] * 2) % MOD  # 더 작은 직사각형을 만드는 방법을 2배로 고려

        # 항상 마지막에 2가지 특수한 방법이 추가됨 (추가적인 타일링 방법이 존재)
        dp[i] = (dp[i] + 2) % MOD

        # dp 테이블의 현재 상태 출력
        print(f"dp[{i}] = {dp[i]} (가로 길이가 {i}일 때 방법의 수)")

    # 가로 길이가 n일 때 직사각형을 채우는 방법의 수를 반환
    return dp[n]


# 테스트
n = 8
print(f"최종 결과: {solution(n)}")  # 출력: 11
